__author__ = 'Павел Новиков (aka VokiVon)'

import random

"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив, 
заданный случайными числами на промежутке [-100; 100). 
Выведите на экран исходный и отсортированный массивы. 
Сортировка должна быть реализована в виде функции. 
По возможности доработайте алгоритм (сделайте его умнее).
"""
# сделаны переменными для возможности переопределения в модулях
size = 20
min_item = -100  # -100 включительно
max_item = 99    # 100 не включая

def gen_array():
    """
    :return: сгенерированный массив по заданным параметрам констант
    """
    return [random.randint(min_item, max_item) for _ in range(size)]


def bubble_sort_reverse(arr_):
    """
    Сортировка пузырьком, как на уроке
    :param arr_: сортируемый массив
    :return: отсортированный массив
    """
    n = 1
    while n < len(arr_):

        for i in range(len(arr_) - 1):  # заменил на n
            if arr_[i] < arr_[i + 1]:   # изменил знак сравнения, чтобы всплывал минимальный элемент
                arr_[i], arr_[i + 1] = arr_[i + 1], arr_[i]
        n += 1

        # print(arr_)
    return arr_

# первая версия оптимизации
# def ext_bubble_sort_reverse(arr_): ver 01
#     """
#     Сортировка пузырьком, попытка улучшить )))
#
#     :param arr_: сортируемый массив
#     :return: отсортированный массив
#     """
#     n = 1
#     # флаг - был ли хотя бы один обмен при проходе
#     # позволяет убрать лишние проходы если уже отсортирован
#     is_swapped = True
#     while is_swapped:
#         is_swapped = False
#         # на уроке стояла 1, заменил на n, т.к. при каждом проходе макс элемент уже на месте
#         for i in range(len(arr_) - n):  # заменил на n
#             if arr_[i] < arr_[i + 1]:   # изменил знак сравнения, чтобы всплывал минимальный элемент
#                 arr_[i], arr_[i + 1] = arr_[i + 1], arr_[i]
#                 is_swapped = True
#         n += 1
#
#         # print(arr_)
#     return arr_

def ext_bubble_sort_reverse(arr_):
    """
    Сортировка пузырьком, попытка улучшить )))

    :param arr_: сортируемый массив
    :return: отсортированный массив
    """
    # запоминаем индекс последнего обмена в ряду
    # при следующем проходе идем только до него, тк справа уже все отсортировано
    # изначально равен последнему индексу
    idx_swp = len(arr_) - 1

    # флаг - был ли хотя бы один обмен при проходе
    # позволяет убрать лишние проходы если уже отсортирован
    is_swapped = True
    while is_swapped:
        is_swapped = False
        # на уроке стояла 1, заменил на n, т.к. при каждом проходе макс элемент уже на месте
        for i in range(idx_swp):  # заменил на n
            if arr_[i] < arr_[i + 1]:   # изменил знак сравнения, чтобы всплывал минимальный элемент
                arr_[i], arr_[i + 1] = arr_[i + 1], arr_[i]
                idx_swp = i  # запоминаем индекс последнего обмена в ряду
                is_swapped = True

        # print(arr_)
    return arr_

# =================
# вывод результатов

array = gen_array()
print(array)
print(bubble_sort_reverse(array))

random.shuffle(array)
print(array)
print(ext_bubble_sort_reverse(array))
